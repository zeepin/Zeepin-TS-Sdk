{"remainingRequest":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/thread-loader/dist/cjs.js!/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js!/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js??ref--13-3!/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/privateKey.ts","dependencies":[{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/privateKey.ts","mtime":1556783746000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport _classCallCheck from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/inherits\";\nimport * as elliptic from 'elliptic';\nimport { randomBytes, isBase64 } from \"../common/functionsUtils\";\nimport { ERROR_CODE } from \"../common/error\";\nimport { Key } from \"./key\";\nimport { KeyType, SignatureScheme } from \"./cryptoParams\";\nimport { PublicKey } from \"./publicKey\";\nimport { Address } from \"../wallet/address\";\nimport { encryptWithGcm, decryptWithGcm } from \"./scrypt\";\nimport { Signature } from \"./signature\";\nimport { DEFAULT_SCRYPT } from \"../common/consts\";\nexport var PrivateKey =\n/*#__PURE__*/\nfunction (_Key) {\n  _inherits(PrivateKey, _Key);\n\n  function PrivateKey() {\n    _classCallCheck(this, PrivateKey);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PrivateKey).apply(this, arguments));\n  }\n\n  _createClass(PrivateKey, [{\n    key: \"getPublicKey\",\n\n    /**\n     * Derives Public key out of Private key.\n     */\n    value: function getPublicKey() {\n      switch (this.algorithm) {\n        case KeyType.ECDSA:\n          return this.getEcDSAPublicKey();\n\n        case KeyType.EDDSA:\n          return this.getEdDSAPublicKey();\n        // case KeyType.SM2:\n        //     return this.getSM2PublicKey();\n\n        default:\n          throw new Error('Unsupported signature schema.');\n      }\n    }\n    /**\n     * Derives Public key out of Private key using EcDSA algorithm.\n     */\n\n  }, {\n    key: \"getEcDSAPublicKey\",\n    value: function getEcDSAPublicKey() {\n      var ec = new elliptic.ec(this.parameters.curve.preset);\n      var keyPair = ec.keyFromPrivate(this.key, 'hex');\n      var pk = keyPair.getPublic(true, 'hex');\n      return new PublicKey(pk, this.algorithm, this.parameters);\n    }\n    /**\n     * Derives Public key out of Private key using EdDSA algorithm.\n     */\n\n  }, {\n    key: \"getEdDSAPublicKey\",\n    value: function getEdDSAPublicKey() {\n      var eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n      var keyPair = eddsa.keyFromSecret(this.key, 'hex');\n      var pk = keyPair.getPublic(true, 'hex');\n      return new PublicKey(pk, this.algorithm, this.parameters);\n    }\n    /**\n     * Decrypts encrypted private key with supplied password.\n     *\n     * @param keyphrase Password to decrypt with\n     * @param address For aad in decryption\n     * @param 16 secure random bytes\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(keyphrase, address, salt, n) {\n      if (salt.length === 24 && isBase64(salt)) {\n        salt = Buffer.from(salt, 'base64').toString('hex');\n      }\n\n      var params;\n\n      if (!n) {\n        params = DEFAULT_SCRYPT;\n      } else {\n        params = {\n          cost: n,\n          blockSize: 8,\n          parallel: 8,\n          size: 64\n        };\n      }\n\n      var decrypted = decryptWithGcm(this.key, address, salt, keyphrase, params);\n      var decryptedKey = new PrivateKey(decrypted, this.algorithm, this.parameters);\n      var pk = decryptedKey.getPublicKey();\n      var addrTmp = Address.fromPubKey(pk);\n\n      if (addrTmp.toBase58() !== address.toBase58()) {\n        throw ERROR_CODE.Decrypto_ERROR;\n      }\n\n      return decryptedKey;\n    }\n    /**\n     * Encrypts private key with supplied password.\n     *\n     * @param keyphrase Password to encrypt with\n     * @param address For aad in encryption\n     * @param salt 16 secure random bytes\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(keyphrase, address, salt, n) {\n      var publicKey = this.getPublicKey();\n      var addr = Address.fromPubKey(publicKey).toBase58();\n\n      if (addr !== address.toBase58()) {\n        throw ERROR_CODE.INVALID_ADDR;\n      }\n\n      var params;\n\n      if (!n) {\n        params = DEFAULT_SCRYPT;\n      } else {\n        params = {\n          cost: n,\n          blockSize: 8,\n          parallel: 8,\n          size: 64\n        };\n      }\n\n      var encrypted = encryptWithGcm(this.key, address, salt, keyphrase, params);\n      return new PrivateKey(encrypted, this.algorithm, this.parameters);\n    }\n    /**\n     * Signs the data with supplied private key using signature schema.\n     *\n     * If the signature schema is not provided, the default schema for this key type is used.\n     *\n     * This method is not suitable, if external keys (Ledger, TPM, ...) support is required.\n     *\n     * @param msg Hex encoded input data or Signable object\n     * @param schema Signing schema to use\n     * @param publicKeyId Id of public key\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(msg, schema, publicKeyId) {\n      if (schema === undefined) {\n        schema = this.algorithm.defaultSchema;\n      }\n\n      if (!this.isSchemaSupported(schema)) {\n        throw new Error('Signature schema does not match key type.');\n      } // retrieves content to sign if not provided directly\n\n\n      if (typeof msg !== 'string') {\n        msg = msg.getSignContent();\n      }\n\n      var hash;\n\n      if (schema === SignatureScheme.SM2withSM3) {\n        // library sm.js (SM2withSM3) has implemented hashing as part of signing, therefore it is skipped\n        hash = msg;\n      } else {\n        hash = this.computeHash(msg, schema);\n      }\n\n      var signed = this.computeSignature(hash, schema);\n      return new Signature(schema, signed, publicKeyId);\n    }\n    /**\n     * Computes signature of message hash using specified signature schema.\n     *\n     * @param hash Message hash\n     * @param schema Signature schema to use\n     */\n\n  }, {\n    key: \"computeSignature\",\n    value: function computeSignature(hash, schema) {\n      switch (schema) {\n        case SignatureScheme.ECDSAwithSHA224:\n        case SignatureScheme.ECDSAwithSHA256:\n        case SignatureScheme.ECDSAwithSHA384:\n        case SignatureScheme.ECDSAwithSHA512:\n        case SignatureScheme.ECDSAwithSHA3_224:\n        case SignatureScheme.ECDSAwithSHA3_256:\n        case SignatureScheme.ECDSAwithSHA3_384:\n        case SignatureScheme.ECDSAwithSHA3_512:\n        case SignatureScheme.ECDSAwithRIPEMD160:\n          return this.computeEcDSASignature(hash);\n\n        case SignatureScheme.EDDSAwithSHA512:\n          return this.computeEdDSASignature(hash);\n        // case SignatureScheme.SM2withSM3:\n        //     return this.computeSM2Signature(hash);\n\n        default:\n          throw new Error('Unsupported signature schema.');\n      }\n    }\n    /**\n     * Computes EcDSA signature of message hash. Curve name is derrived from private key.\n     *\n     * @param hash Message hash\n     */\n\n  }, {\n    key: \"computeEcDSASignature\",\n    value: function computeEcDSASignature(hash) {\n      var ec = new elliptic.ec(this.parameters.curve.preset);\n      var signed = ec.sign(hash, this.key, {\n        canonical: true\n      });\n      return Buffer.concat([signed.r.toArrayLike(Buffer, 'be', 32), signed.s.toArrayLike(Buffer, 'be', 32)]).toString('hex');\n    }\n    /**\n     * Computes EdDSA signature of message hash. Curve name is derrived from private key.\n     *\n     * @param hash Message hash\n     */\n\n  }, {\n    key: \"computeEdDSASignature\",\n    value: function computeEdDSASignature(hash) {\n      var eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n      var signed = eddsa.sign(hash, this.key, null);\n      return Buffer.concat([signed.R.toArrayLike(Buffer, 'be', 32), signed.S.toArrayLike(Buffer, 'be', 32)]).toString('hex');\n    }\n  }], [{\n    key: \"random\",\n\n    /**\n     * Generates random Private key using supplied Key type and parameters.\n     *\n     * If no Key type or parameters is supplied, default SDK key type with default parameters will be used.\n     */\n    value: function random(keyType, parameters) {\n      return new PrivateKey(randomBytes(32), keyType, parameters);\n    }\n  }]);\n\n  return PrivateKey;\n}(Key);",null]}