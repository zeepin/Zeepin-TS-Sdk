{"remainingRequest":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js!/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js??ref--13-2!/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/scrypt.ts","dependencies":[{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/scrypt.ts","mtime":1556782440000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport * as asyncScrypt from 'scrypt-async'; //import asyncScrypt from './scrypt-async.min.js';\n\nimport { createCipheriv, createDecipheriv } from 'crypto';\nimport { ERROR_CODE } from \"../common/error\";\nimport { hexstring2ab, isHexString } from \"../common/functionsUtils\";\n/**\n * Synchronious call to scrypt-async-js.\n *\n * @param keyphrase Keyphrase to use\n * @param addressHash Hex encoded address\n * @param params Scrypt params\n */\n\nfunction scrypt(keyphrase, addressHash, params) {\n  var derived = [];\n  asyncScrypt(keyphrase.normalize('NFC'), hexstring2ab(addressHash), {\n    N: params.cost,\n    r: params.blockSize,\n    p: params.parallel,\n    dkLen: params.size\n  }, function (result) {\n    derived = result;\n  });\n  return new Buffer(derived);\n}\n/**\n * Encrypt with aes-gcm-256\n * This is the default encryption algorithm for private key\n * @param privateKey Private key to encpryt with\n * @param address Adderss to encrypt with\n * @param salt Salt to encrypt with\n * @param keyphrase User's password\n * @param scryptParams Optional params to encrypt\n */\n\n\nexport function encryptWithGcm(privateKey, address, salt, keyphrase, scryptParams) {\n  if (!isHexString(privateKey)) {\n    throw new Error(ERROR_CODE.INVALID_PARAMS + ', Invalid private key');\n  }\n\n  var derived = scrypt(keyphrase, salt, scryptParams);\n  var derived1 = derived.slice(0, 12);\n  var derived2 = derived.slice(32);\n  var key = derived2;\n  var iv = derived1;\n  var aad = new Buffer(address.toBase58());\n  var cipher = createCipheriv('aes-256-gcm', key, iv);\n  cipher.setAAD(aad);\n  var plainText = Buffer.from(privateKey, 'hex');\n  var ciphertext = cipher.update(plainText);\n  var final = cipher.final();\n  var authTag = cipher.getAuthTag();\n  ciphertext = Buffer.concat([ciphertext, final]);\n  var result = Buffer.concat([ciphertext, authTag]);\n  return result.toString('base64');\n}\n/**\n * Decrypt with aes-256-gcm\n * @param encrypted Encrypted private key\n * @param address Address to decrypt with\n * @param salt Salt to decrypt with\n * @param keyphrase User's password\n * @param scryptParams Optioanl params to decrypt with\n */\n\nexport function decryptWithGcm(encrypted, address, salt, keyphrase, scryptParams) {\n  if (salt.length !== 32) {\n    throw ERROR_CODE.INVALID_PARAMS;\n  }\n\n  var result = Buffer.from(encrypted, 'base64');\n  var ciphertext = result.slice(0, result.length - 16);\n  var authTag = result.slice(result.length - 16);\n  var derived = scrypt(keyphrase, salt, scryptParams);\n  var derived1 = derived.slice(0, 12);\n  var derived2 = derived.slice(32);\n  var key = derived2;\n  var iv = derived1;\n  var aad = new Buffer(address.toBase58()); // const auth = new Buffer(authTag, 'hex');\n\n  var decipher = createDecipheriv('aes-256-gcm', key, iv);\n  decipher.setAAD(aad);\n  decipher.setAuthTag(authTag);\n  var decrypted = decipher.update(ciphertext).toString('hex');\n\n  try {\n    decrypted += decipher.final().toString('hex');\n  } catch (err) {\n    throw ERROR_CODE.Decrypto_ERROR;\n  }\n\n  return decrypted;\n}",{"version":3,"sources":["/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/scrypt.ts"],"names":[],"mappings":";;AAAA,OAAO,KAAK,WAAZ,MAA6B,cAA7B,C,CACA;;AACA,SAAS,cAAT,EAAyB,gBAAzB,QAAiD,QAAjD;AAEA,SAAS,UAAT,QAA2B,iBAA3B;AACA,SAAS,YAAT,EAAuB,WAAvB,QAA0C,0BAA1C;AAWA;;;;;;;;AAOA,SAAS,MAAT,CAAgB,SAAhB,EAAmC,WAAnC,EAAwD,MAAxD,EAA4E;AACxE,MAAI,OAAO,GAAa,EAAxB;AACA,EAAA,WAAW,CACP,SAAS,CAAC,SAAV,CAAoB,KAApB,CADO,EAEP,YAAY,CAAC,WAAD,CAFL,EAGP;AACI,IAAA,CAAC,EAAE,MAAM,CAAC,IADd;AAEI,IAAA,CAAC,EAAE,MAAM,CAAC,SAFd;AAGI,IAAA,CAAC,EAAE,MAAM,CAAC,QAHd;AAII,IAAA,KAAK,EAAE,MAAM,CAAC;AAJlB,GAHO,EASP,UAAC,MAAD,EAA8B;AAC1B,IAAA,OAAO,GAAG,MAAV;AACH,GAXM,CAAX;AAaA,SAAO,IAAI,MAAJ,CAAW,OAAX,CAAP;AACH;AAED;;;;;;;;;;;AASA,OAAM,SAAU,cAAV,CACF,UADE,EAEF,OAFE,EAGF,IAHE,EAIF,SAJE,EAKF,YALE,EAKwB;AAE1B,MAAI,CAAC,WAAW,CAAC,UAAD,CAAhB,EAA8B;AAC1B,UAAM,IAAI,KAAJ,CAAU,UAAU,CAAC,cAAX,GAA4B,uBAAtC,CAAN;AACH;;AACD,MAAM,OAAO,GAAG,MAAM,CAAC,SAAD,EAAY,IAAZ,EAAkB,YAAlB,CAAtB;AACA,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,EAAjB,CAAjB;AACA,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAR,CAAc,EAAd,CAAjB;AACA,MAAM,GAAG,GAAG,QAAZ;AACA,MAAM,EAAE,GAAG,QAAX;AACA,MAAM,GAAG,GAAG,IAAI,MAAJ,CAAW,OAAO,CAAC,QAAR,EAAX,CAAZ;AACA,MAAM,MAAM,GAAG,cAAc,CAAC,aAAD,EAAgB,GAAhB,EAAqB,EAArB,CAA7B;AACA,EAAA,MAAM,CAAC,MAAP,CAAc,GAAd;AACA,MAAM,SAAS,GAAG,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,KAAxB,CAAlB;AACA,MAAI,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,SAAd,CAAjB;AACA,MAAM,KAAK,GAAG,MAAM,CAAC,KAAP,EAAd;AACA,MAAM,OAAO,GAAG,MAAM,CAAC,UAAP,EAAhB;AACA,EAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,CAAC,UAAD,EAAa,KAAb,CAAd,CAAb;AAEA,MAAM,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,CAAC,UAAD,EAAa,OAAb,CAAd,CAAf;AACA,SAAO,MAAM,CAAC,QAAP,CAAgB,QAAhB,CAAP;AACH;AAED;;;;;;;;;AAQA,OAAM,SAAU,cAAV,CACF,SADE,EAEF,OAFE,EAGF,IAHE,EAIF,SAJE,EAKF,YALE,EAKwB;AAE1B,MAAI,IAAI,CAAC,MAAL,KAAgB,EAApB,EAAwB;AACpB,UAAM,UAAU,CAAC,cAAjB;AACH;;AACD,MAAM,MAAM,GAAG,MAAM,CAAC,IAAP,CAAY,SAAZ,EAAuB,QAAvB,CAAf;AACA,MAAM,UAAU,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,EAAgB,MAAM,CAAC,MAAP,GAAgB,EAAhC,CAAnB;AACA,MAAM,OAAO,GAAG,MAAM,CAAC,KAAP,CAAa,MAAM,CAAC,MAAP,GAAgB,EAA7B,CAAhB;AACA,MAAM,OAAO,GAAG,MAAM,CAAC,SAAD,EAAY,IAAZ,EAAkB,YAAlB,CAAtB;AACA,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,EAAjB,CAAjB;AACA,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAR,CAAc,EAAd,CAAjB;AACA,MAAM,GAAG,GAAG,QAAZ;AACA,MAAM,EAAE,GAAG,QAAX;AACA,MAAM,GAAG,GAAG,IAAI,MAAJ,CAAW,OAAO,CAAC,QAAR,EAAX,CAAZ,CAb0B,CAc1B;;AACA,MAAM,QAAQ,GAAG,gBAAgB,CAAC,aAAD,EAAgB,GAAhB,EAAqB,EAArB,CAAjC;AACA,EAAA,QAAQ,CAAC,MAAT,CAAgB,GAAhB;AACA,EAAA,QAAQ,CAAC,UAAT,CAAoB,OAApB;AACA,MAAI,SAAS,GAAG,QAAQ,CAAC,MAAT,CAAgB,UAAhB,EAA4B,QAA5B,CAAqC,KAArC,CAAhB;;AACA,MAAI;AACA,IAAA,SAAS,IAAI,QAAQ,CAAC,KAAT,GAAiB,QAAjB,CAA0B,KAA1B,CAAb;AACH,GAFD,CAEE,OAAO,GAAP,EAAY;AACV,UAAM,UAAU,CAAC,cAAjB;AACH;;AACD,SAAO,SAAP;AACH","sourcesContent":["import * as asyncScrypt from 'scrypt-async';\n//import asyncScrypt from './scrypt-async.min.js';\nimport { createCipheriv, createDecipheriv } from 'crypto';\nimport { DEFAULT_SCRYPT } from \"../common/consts\";\nimport { ERROR_CODE } from \"../common/error\";\nimport { hexstring2ab, isHexString } from \"../common/functionsUtils\";\nimport { Address } from \"../wallet/address\";\n\n\nexport interface ScryptParams {\n    cost: number;\n    blockSize: number;\n    parallel: number;\n    size: number;\n}\n\n/**\n * Synchronious call to scrypt-async-js.\n *\n * @param keyphrase Keyphrase to use\n * @param addressHash Hex encoded address\n * @param params Scrypt params\n */\nfunction scrypt(keyphrase: string, addressHash: string, params: ScryptParams) {\n    let derived: number[] = [];\n    asyncScrypt(\n        keyphrase.normalize('NFC'),\n        hexstring2ab(addressHash),\n        {\n            N: params.cost,\n            r: params.blockSize,\n            p: params.parallel,\n            dkLen: params.size\n        },\n        (result: string | number[]) => {\n            derived = result as number[];\n        }\n    );\n    return new Buffer(derived);\n}\n\n/**\n * Encrypt with aes-gcm-256\n * This is the default encryption algorithm for private key\n * @param privateKey Private key to encpryt with\n * @param address Adderss to encrypt with\n * @param salt Salt to encrypt with\n * @param keyphrase User's password\n * @param scryptParams Optional params to encrypt\n */\nexport function encryptWithGcm(\n    privateKey: string,\n    address: Address,\n    salt: string,\n    keyphrase: string,\n    scryptParams: ScryptParams\n) {\n    if (!isHexString(privateKey)) {\n        throw new Error(ERROR_CODE.INVALID_PARAMS + ', Invalid private key');\n    }\n    const derived = scrypt(keyphrase, salt, scryptParams);\n    const derived1 = derived.slice(0, 12);\n    const derived2 = derived.slice(32);\n    const key = derived2;\n    const iv = derived1;\n    const aad = new Buffer(address.toBase58());\n    const cipher = createCipheriv('aes-256-gcm', key, iv);\n    cipher.setAAD(aad);\n    const plainText = Buffer.from(privateKey, 'hex');\n    let ciphertext = cipher.update(plainText);\n    const final = cipher.final();\n    const authTag = cipher.getAuthTag();\n    ciphertext = Buffer.concat([ciphertext, final]);\n\n    const result = Buffer.concat([ciphertext, authTag]);\n    return result.toString('base64');\n}\n\n/**\n * Decrypt with aes-256-gcm\n * @param encrypted Encrypted private key\n * @param address Address to decrypt with\n * @param salt Salt to decrypt with\n * @param keyphrase User's password\n * @param scryptParams Optioanl params to decrypt with\n */\nexport function decryptWithGcm(\n    encrypted: string,\n    address: Address,\n    salt: string,\n    keyphrase: string,\n    scryptParams: ScryptParams\n) {\n    if (salt.length !== 32) {\n        throw ERROR_CODE.INVALID_PARAMS;\n    }\n    const result = Buffer.from(encrypted, 'base64');\n    const ciphertext = result.slice(0, result.length - 16);\n    const authTag = result.slice(result.length - 16);\n    const derived = scrypt(keyphrase, salt, scryptParams);\n    const derived1 = derived.slice(0, 12);\n    const derived2 = derived.slice(32);\n    const key = derived2;\n    const iv = derived1;\n    const aad = new Buffer(address.toBase58());\n    // const auth = new Buffer(authTag, 'hex');\n    const decipher = createDecipheriv('aes-256-gcm', key, iv);\n    decipher.setAAD(aad);\n    decipher.setAuthTag(authTag);\n    let decrypted = decipher.update(ciphertext).toString('hex');\n    try {\n        decrypted += decipher.final().toString('hex');\n    } catch (err) {\n        throw ERROR_CODE.Decrypto_ERROR;\n    }\n    return decrypted;\n}\n\n"],"sourceRoot":""}]}