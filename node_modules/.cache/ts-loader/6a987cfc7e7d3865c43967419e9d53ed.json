{"remainingRequest":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/thread-loader/dist/cjs.js!/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js!/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js??ref--13-3!/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/common/functionsUtils.ts","dependencies":[{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/common/functionsUtils.ts","mtime":1555654528000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.iterator\";\nimport _getIterator from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/core-js/get-iterator\";\nimport \"core-js/modules/es6.string.repeat\";\nimport _Number$isSafeInteger from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/core-js/number/is-safe-integer\";\nimport \"core-js/modules/es6.typed.uint8-array\";\nimport _parseInt from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/core-js/parse-int\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport * as cryptoJS from 'crypto-js';\nimport { ERROR_CODE } from \"./error\";\n/**\n * Creates random bytes.\n *\n * @param data Hex encoded data\n */\n\nexport function randomBytes(len) {\n  return cryptoJS.lib.WordArray.random(len).toString();\n  ;\n}\n/**\n * Computes sha-256 hash from hex encoded data.\n *\n * @param data Hex encoded data\n */\n\nexport function sha256(data) {\n  var hex = cryptoJS.enc.Hex.parse(data);\n  var sha = cryptoJS.SHA256(hex).toString();\n  return sha;\n}\n/**\n * Turn hex string into array buffer\n * @param str hex string\n */\n\nexport function hexstring2ab(str) {\n  var result = [];\n\n  while (str.length >= 2) {\n    result.push(_parseInt(str.substring(0, 2), 16));\n    str = str.substring(2, str.length);\n  }\n\n  return result;\n}\n/**\n * Turn array buffer into hex string\n * @param arr Array like value\n */\n\nexport function ab2hexstring(arr) {\n  var result = '';\n  var uint8Arr = new Uint8Array(arr);\n\n  for (var i = 0; i < uint8Arr.byteLength; i++) {\n    var str = uint8Arr[i].toString(16);\n    str = str.length === 0 ? '00' : str.length === 1 ? '0' + str : str;\n    result += str;\n  }\n\n  return result;\n}\n/**\n * Converts a number to a big endian hexstring of a suitable size, optionally little endian\n * @param {number} num\n * @param {number} size - The required size in bytes, eg 1 for Uint8, 2 for Uint16. Defaults to 1.\n * @param {boolean} littleEndian - Encode the hex in little endian form\n * @return {string}\n */\n\nexport var num2hexstring = function num2hexstring(num) {\n  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var littleEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (num < 0) {\n    throw new RangeError('num must be >=0');\n  }\n\n  if (size % 1 !== 0) {\n    throw new Error('size must be a whole integer');\n  }\n\n  if (!_Number$isSafeInteger(num)) {\n    throw new RangeError(\"num (\".concat(num, \") must be a safe integer\"));\n  }\n\n  size = size * 2;\n  var hexstring = num.toString(16);\n  hexstring = hexstring.length % size === 0 ? hexstring : ('0'.repeat(size) + hexstring).substring(hexstring.length);\n\n  if (littleEndian) {\n    hexstring = reverseHex(hexstring);\n  }\n\n  return hexstring;\n};\n/**\n * Turn normal string into ArrayBuffer\n * @param str Normal string\n */\n\nexport function str2ab(str) {\n  var buf = new ArrayBuffer(str.length); // 每个字符占用1个字节\n\n  var bufView = new Uint8Array(buf);\n\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n\n  return buf;\n}\n/**\n * Turn ArrayBuffer or array-like oject into normal string\n * @param buf\n */\n\nexport function ab2str(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf));\n}\n/**\n * Turn normal string into hex string\n * @param str Normal string\n */\n\nexport function str2hexstr(str) {\n  return ab2hexstring(str2ab(str));\n}\n/**\n * Turn hex string into normal string\n * @param str Hex string\n */\n\nexport function hexstr2str(str) {\n  return ab2str(hexstring2ab(str));\n}\n/**\n * return the (length of bytes) + bytes\n * @param hex Hex string\n */\n\nexport function hex2VarBytes(hex) {\n  var result = '';\n  result += num2VarInt(hex.length / 2);\n  result += hex;\n  return result;\n}\n/**\n * Converts a number to a hex\n * @param {number} num - The number\n * @returns {string} hexstring of the variable Int.\n */\n\nexport var num2VarInt = function num2VarInt(num) {\n  if (num < 0xfd) {\n    return num2hexstring(num);\n  } else if (num <= 0xffff) {\n    // uint16\n    return 'fd' + num2hexstring(num, 2, true);\n  } else if (num <= 0xffffffff) {\n    // uint32\n    return 'fe' + num2hexstring(num, 4, true);\n  } else {\n    // uint64\n    return 'ff' + num2hexstring(num, 8, true);\n  }\n}; // @ts-ignore\n\nexport function bigIntToBytes(value) {\n  var data = value.toBytesLE();\n  var negData = value.neg().toBytesLE();\n  var stop;\n\n  if (value.isNegative()) {\n    stop = 255;\n  } else {\n    stop = 0;\n  }\n\n  var b = stop;\n  var pos = 0;\n\n  for (var i = data.length - 1; i >= 0; i--) {\n    if (data[i] !== stop) {\n      b = value.isNegative() ? negData[i] : data[i];\n      pos = i + 1;\n      break;\n    }\n  }\n\n  data = data.slice(0, pos);\n\n  if (b >> 7 === 1) {\n    data.push(value.isNegative() ? 255 : 0);\n  }\n\n  return new Buffer(data).toString('hex');\n}\n/**\n * Reverses a hex string, 2 chars as 1 byte\n * @example\n * reverseHex('abcdef') = 'efcdab'\n * @param {string} hex - HEX string\n * @return {string} reversed hex string.\n */\n\nexport var reverseHex = function reverseHex(hex) {\n  if (hex.length % 2 !== 0) {\n    throw new Error(\"Incorrect Length: \".concat(hex));\n  }\n\n  var out = '';\n\n  for (var i = hex.length - 2; i >= 0; i -= 2) {\n    out += hex.substr(i, 2);\n  }\n\n  return out;\n};\n/**\n * Computes ripemd-160 hash of sha-256 hash from hex encoded data.\n *\n * @param data Hex encoded data\n */\n\nexport function hash160(SignatureScript) {\n  return ripemd160(sha256(SignatureScript));\n}\n/**\n * Computes ripemd-160 hash from hex encoded data.\n *\n * @param data Hex encoded data\n */\n\nexport function ripemd160(data) {\n  var hex = cryptoJS.enc.Hex.parse(data);\n  var ripemd = cryptoJS.RIPEMD160(hex).toString();\n  return ripemd;\n}\nexport function isHexString(str) {\n  var regexp = /^[0-9a-fA-F]+$/;\n  return regexp.test(str) && str.length % 2 === 0;\n}\nexport function isBase64(str) {\n  return Buffer.from(str, 'base64').toString('base64') === str;\n}\n/**\n * Concat params as the query part in rest\n * @param params\n */\n\nexport function concatParams(params) {\n  var result = '';\n\n  if (params.size === 0) {\n    return '';\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = _getIterator(params.keys()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n      var value = params.get(key);\n\n      if (value) {\n        value = encodeURIComponent(value);\n      }\n\n      result += \"&\".concat(key, \"=\").concat(value);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return '?' + result.substr(1);\n}\nexport function keystoreCheck(keystore) {\n  if (!keystore.hasOwnProperty('accounts')) {\n    throw ERROR_CODE.Keystore_ERROR;\n  } // @ts-ignore\n\n\n  var account = keystore.accounts[0];\n\n  if (!account.hasOwnProperty('address')) {\n    throw ERROR_CODE.Keystore_ERROR;\n  }\n\n  if (!account.hasOwnProperty('key')) {\n    throw ERROR_CODE.Keystore_ERROR;\n  }\n\n  if (!account.hasOwnProperty('salt')) {\n    throw ERROR_CODE.Keystore_ERROR;\n  }\n}",null]}