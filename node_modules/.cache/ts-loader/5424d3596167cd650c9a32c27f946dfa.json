{"remainingRequest":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js!/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js??ref--13-2!/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/privateKey.ts","dependencies":[{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/privateKey.ts","mtime":1556783746000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport _classCallCheck from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/inherits\";\nimport * as elliptic from 'elliptic';\nimport { randomBytes, isBase64 } from \"../common/functionsUtils\";\nimport { ERROR_CODE } from \"../common/error\";\nimport { Key } from \"./key\";\nimport { KeyType, SignatureScheme } from \"./cryptoParams\";\nimport { PublicKey } from \"./publicKey\";\nimport { Address } from \"../wallet/address\";\nimport { encryptWithGcm, decryptWithGcm } from \"./scrypt\";\nimport { Signature } from \"./signature\";\nimport { DEFAULT_SCRYPT } from \"../common/consts\";\nexport var PrivateKey =\n/*#__PURE__*/\nfunction (_Key) {\n  _inherits(PrivateKey, _Key);\n\n  function PrivateKey() {\n    _classCallCheck(this, PrivateKey);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PrivateKey).apply(this, arguments));\n  }\n\n  _createClass(PrivateKey, [{\n    key: \"getPublicKey\",\n\n    /**\n     * Derives Public key out of Private key.\n     */\n    value: function getPublicKey() {\n      switch (this.algorithm) {\n        case KeyType.ECDSA:\n          return this.getEcDSAPublicKey();\n\n        case KeyType.EDDSA:\n          return this.getEdDSAPublicKey();\n        // case KeyType.SM2:\n        //     return this.getSM2PublicKey();\n\n        default:\n          throw new Error('Unsupported signature schema.');\n      }\n    }\n    /**\n     * Derives Public key out of Private key using EcDSA algorithm.\n     */\n\n  }, {\n    key: \"getEcDSAPublicKey\",\n    value: function getEcDSAPublicKey() {\n      var ec = new elliptic.ec(this.parameters.curve.preset);\n      var keyPair = ec.keyFromPrivate(this.key, 'hex');\n      var pk = keyPair.getPublic(true, 'hex');\n      return new PublicKey(pk, this.algorithm, this.parameters);\n    }\n    /**\n     * Derives Public key out of Private key using EdDSA algorithm.\n     */\n\n  }, {\n    key: \"getEdDSAPublicKey\",\n    value: function getEdDSAPublicKey() {\n      var eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n      var keyPair = eddsa.keyFromSecret(this.key, 'hex');\n      var pk = keyPair.getPublic(true, 'hex');\n      return new PublicKey(pk, this.algorithm, this.parameters);\n    }\n    /**\n     * Decrypts encrypted private key with supplied password.\n     *\n     * @param keyphrase Password to decrypt with\n     * @param address For aad in decryption\n     * @param 16 secure random bytes\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(keyphrase, address, salt, n) {\n      if (salt.length === 24 && isBase64(salt)) {\n        salt = Buffer.from(salt, 'base64').toString('hex');\n      }\n\n      var params;\n\n      if (!n) {\n        params = DEFAULT_SCRYPT;\n      } else {\n        params = {\n          cost: n,\n          blockSize: 8,\n          parallel: 8,\n          size: 64\n        };\n      }\n\n      var decrypted = decryptWithGcm(this.key, address, salt, keyphrase, params);\n      var decryptedKey = new PrivateKey(decrypted, this.algorithm, this.parameters);\n      var pk = decryptedKey.getPublicKey();\n      var addrTmp = Address.fromPubKey(pk);\n\n      if (addrTmp.toBase58() !== address.toBase58()) {\n        throw ERROR_CODE.Decrypto_ERROR;\n      }\n\n      return decryptedKey;\n    }\n    /**\n     * Encrypts private key with supplied password.\n     *\n     * @param keyphrase Password to encrypt with\n     * @param address For aad in encryption\n     * @param salt 16 secure random bytes\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(keyphrase, address, salt, n) {\n      var publicKey = this.getPublicKey();\n      var addr = Address.fromPubKey(publicKey).toBase58();\n\n      if (addr !== address.toBase58()) {\n        throw ERROR_CODE.INVALID_ADDR;\n      }\n\n      var params;\n\n      if (!n) {\n        params = DEFAULT_SCRYPT;\n      } else {\n        params = {\n          cost: n,\n          blockSize: 8,\n          parallel: 8,\n          size: 64\n        };\n      }\n\n      var encrypted = encryptWithGcm(this.key, address, salt, keyphrase, params);\n      return new PrivateKey(encrypted, this.algorithm, this.parameters);\n    }\n    /**\n     * Signs the data with supplied private key using signature schema.\n     *\n     * If the signature schema is not provided, the default schema for this key type is used.\n     *\n     * This method is not suitable, if external keys (Ledger, TPM, ...) support is required.\n     *\n     * @param msg Hex encoded input data or Signable object\n     * @param schema Signing schema to use\n     * @param publicKeyId Id of public key\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(msg, schema, publicKeyId) {\n      if (schema === undefined) {\n        schema = this.algorithm.defaultSchema;\n      }\n\n      if (!this.isSchemaSupported(schema)) {\n        throw new Error('Signature schema does not match key type.');\n      } // retrieves content to sign if not provided directly\n\n\n      if (typeof msg !== 'string') {\n        msg = msg.getSignContent();\n      }\n\n      var hash;\n\n      if (schema === SignatureScheme.SM2withSM3) {\n        // library sm.js (SM2withSM3) has implemented hashing as part of signing, therefore it is skipped\n        hash = msg;\n      } else {\n        hash = this.computeHash(msg, schema);\n      }\n\n      var signed = this.computeSignature(hash, schema);\n      return new Signature(schema, signed, publicKeyId);\n    }\n    /**\n     * Computes signature of message hash using specified signature schema.\n     *\n     * @param hash Message hash\n     * @param schema Signature schema to use\n     */\n\n  }, {\n    key: \"computeSignature\",\n    value: function computeSignature(hash, schema) {\n      switch (schema) {\n        case SignatureScheme.ECDSAwithSHA224:\n        case SignatureScheme.ECDSAwithSHA256:\n        case SignatureScheme.ECDSAwithSHA384:\n        case SignatureScheme.ECDSAwithSHA512:\n        case SignatureScheme.ECDSAwithSHA3_224:\n        case SignatureScheme.ECDSAwithSHA3_256:\n        case SignatureScheme.ECDSAwithSHA3_384:\n        case SignatureScheme.ECDSAwithSHA3_512:\n        case SignatureScheme.ECDSAwithRIPEMD160:\n          return this.computeEcDSASignature(hash);\n\n        case SignatureScheme.EDDSAwithSHA512:\n          return this.computeEdDSASignature(hash);\n        // case SignatureScheme.SM2withSM3:\n        //     return this.computeSM2Signature(hash);\n\n        default:\n          throw new Error('Unsupported signature schema.');\n      }\n    }\n    /**\n     * Computes EcDSA signature of message hash. Curve name is derrived from private key.\n     *\n     * @param hash Message hash\n     */\n\n  }, {\n    key: \"computeEcDSASignature\",\n    value: function computeEcDSASignature(hash) {\n      var ec = new elliptic.ec(this.parameters.curve.preset);\n      var signed = ec.sign(hash, this.key, {\n        canonical: true\n      });\n      return Buffer.concat([signed.r.toArrayLike(Buffer, 'be', 32), signed.s.toArrayLike(Buffer, 'be', 32)]).toString('hex');\n    }\n    /**\n     * Computes EdDSA signature of message hash. Curve name is derrived from private key.\n     *\n     * @param hash Message hash\n     */\n\n  }, {\n    key: \"computeEdDSASignature\",\n    value: function computeEdDSASignature(hash) {\n      var eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n      var signed = eddsa.sign(hash, this.key, null);\n      return Buffer.concat([signed.R.toArrayLike(Buffer, 'be', 32), signed.S.toArrayLike(Buffer, 'be', 32)]).toString('hex');\n    }\n  }], [{\n    key: \"random\",\n\n    /**\n     * Generates random Private key using supplied Key type and parameters.\n     *\n     * If no Key type or parameters is supplied, default SDK key type with default parameters will be used.\n     */\n    value: function random(keyType, parameters) {\n      return new PrivateKey(randomBytes(32), keyType, parameters);\n    }\n  }]);\n\n  return PrivateKey;\n}(Key);",{"version":3,"sources":["/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/privateKey.ts"],"names":[],"mappings":";;;;;;;AAAA,OAAO,KAAK,QAAZ,MAA0B,UAA1B;AACA,SAAS,WAAT,EAAsB,QAAtB,QAAsC,0BAAtC;AACA,SAAS,UAAT,QAA2B,iBAA3B;AACA,SAAS,GAAT,QAAoB,OAApB;AACA,SAAS,OAAT,EAAiC,eAAjC,QAAwD,gBAAxD;AACA,SAAS,SAAT,QAA0B,aAA1B;AACA,SAAS,OAAT,QAAwB,mBAAxB;AACA,SAAS,cAAT,EAAyB,cAAzB,QAA6D,UAA7D;AACA,SAAS,SAAT,QAA0B,aAA1B;AAEA,SAAS,cAAT,QAA+B,kBAA/B;AAEA,WAAa,UAAb;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAUI;;;AAVJ,mCAagB;AACR,cAAQ,KAAK,SAAb;AACI,aAAK,OAAO,CAAC,KAAb;AACI,iBAAO,KAAK,iBAAL,EAAP;;AACJ,aAAK,OAAO,CAAC,KAAb;AACI,iBAAO,KAAK,iBAAL,EAAP;AACJ;AACA;;AACA;AACI,gBAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AARR;AAUH;AAED;;;;AA1BJ;AAAA;AAAA,wCA6BqB;AACb,UAAM,EAAE,GAAG,IAAI,QAAQ,CAAC,EAAb,CAAgB,KAAK,UAAL,CAAgB,KAAhB,CAAsB,MAAtC,CAAX;AACA,UAAM,OAAO,GAAG,EAAE,CAAC,cAAH,CAAkB,KAAK,GAAvB,EAA4B,KAA5B,CAAhB;AACA,UAAM,EAAE,GAAG,OAAO,CAAC,SAAR,CAAkB,IAAlB,EAAwB,KAAxB,CAAX;AAEA,aAAO,IAAI,SAAJ,CAAc,EAAd,EAAkB,KAAK,SAAvB,EAAkC,KAAK,UAAvC,CAAP;AACH;AAED;;;;AArCJ;AAAA;AAAA,wCAwCqB;AACb,UAAM,KAAK,GAAG,IAAI,QAAQ,CAAC,KAAb,CAAmB,KAAK,UAAL,CAAgB,KAAhB,CAAsB,MAAzC,CAAd;AACA,UAAM,OAAO,GAAG,KAAK,CAAC,aAAN,CAAoB,KAAK,GAAzB,EAA8B,KAA9B,CAAhB;AACA,UAAM,EAAE,GAAG,OAAO,CAAC,SAAR,CAAkB,IAAlB,EAAwB,KAAxB,CAAX;AAEA,aAAO,IAAI,SAAJ,CAAc,EAAd,EAAkB,KAAK,SAAvB,EAAkC,KAAK,UAAvC,CAAP;AACH;AAED;;;;;;;;AAhDJ;AAAA;AAAA,4BAuDY,SAvDZ,EAuD+B,OAvD/B,EAuDiD,IAvDjD,EAuD+D,CAvD/D,EAuDyE;AACjE,UAAI,IAAI,CAAC,MAAL,KAAgB,EAAhB,IAAsB,QAAQ,CAAC,IAAD,CAAlC,EAA0C;AACtC,QAAA,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,QAAlB,EAA4B,QAA5B,CAAqC,KAArC,CAAP;AACH;;AACD,UAAI,MAAJ;;AACA,UAAI,CAAC,CAAL,EAAQ;AACJ,QAAA,MAAM,GAAG,cAAT;AACH,OAFD,MAEO;AACH,QAAA,MAAM,GAAG;AACL,UAAA,IAAI,EAAE,CADD;AAEL,UAAA,SAAS,EAAE,CAFN;AAGL,UAAA,QAAQ,EAAE,CAHL;AAIL,UAAA,IAAI,EAAE;AAJD,SAAT;AAMH;;AACD,UAAM,SAAS,GAAG,cAAc,CAAC,KAAK,GAAN,EAAW,OAAX,EAAoB,IAApB,EAA0B,SAA1B,EAAqC,MAArC,CAAhC;AACA,UAAM,YAAY,GAAG,IAAI,UAAJ,CAAe,SAAf,EAA0B,KAAK,SAA/B,EAA0C,KAAK,UAA/C,CAArB;AACA,UAAM,EAAE,GAAG,YAAY,CAAC,YAAb,EAAX;AACA,UAAM,OAAO,GAAG,OAAO,CAAC,UAAR,CAAmB,EAAnB,CAAhB;;AACA,UAAI,OAAO,CAAC,QAAR,OAAuB,OAAO,CAAC,QAAR,EAA3B,EAA+C;AAC3C,cAAM,UAAU,CAAC,cAAjB;AACH;;AACD,aAAO,YAAP;AACH;AAED;;;;;;;;AAhFJ;AAAA;AAAA,4BAuFY,SAvFZ,EAuF+B,OAvF/B,EAuFiD,IAvFjD,EAuF+D,CAvF/D,EAuFyE;AACjE,UAAM,SAAS,GAAG,KAAK,YAAL,EAAlB;AACA,UAAM,IAAI,GAAG,OAAO,CAAC,UAAR,CAAmB,SAAnB,EAA8B,QAA9B,EAAb;;AACA,UAAI,IAAI,KAAK,OAAO,CAAC,QAAR,EAAb,EAAiC;AAC7B,cAAM,UAAU,CAAC,YAAjB;AACH;;AACD,UAAI,MAAJ;;AACA,UAAI,CAAC,CAAL,EAAQ;AACJ,QAAA,MAAM,GAAG,cAAT;AACH,OAFD,MAEO;AACH,QAAA,MAAM,GAAG;AACL,UAAA,IAAI,EAAE,CADD;AAEL,UAAA,SAAS,EAAE,CAFN;AAGL,UAAA,QAAQ,EAAE,CAHL;AAIL,UAAA,IAAI,EAAE;AAJD,SAAT;AAMH;;AACD,UAAM,SAAS,GAAG,cAAc,CAAC,KAAK,GAAN,EAAW,OAAX,EAAoB,IAApB,EAA0B,SAA1B,EAAqC,MAArC,CAAhC;AACA,aAAO,IAAI,UAAJ,CAAe,SAAf,EAA0B,KAAK,SAA/B,EAA0C,KAAK,UAA/C,CAAP;AACH;AAED;;;;;;;;;;;;AA5GJ;AAAA;AAAA,yBAuHS,GAvHT,EAuHiC,MAvHjC,EAuH2D,WAvH3D,EAuH+E;AACvE,UAAI,MAAM,KAAK,SAAf,EAA0B;AACtB,QAAA,MAAM,GAAG,KAAK,SAAL,CAAe,aAAxB;AACH;;AAED,UAAI,CAAC,KAAK,iBAAL,CAAuB,MAAvB,CAAL,EAAqC;AACjC,cAAM,IAAI,KAAJ,CAAU,2CAAV,CAAN;AACH,OAPsE,CASvE;;;AACA,UAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AACzB,QAAA,GAAG,GAAG,GAAG,CAAC,cAAJ,EAAN;AACH;;AAED,UAAI,IAAJ;;AACA,UAAI,MAAM,KAAK,eAAe,CAAC,UAA/B,EAA2C;AACvC;AACA,QAAA,IAAI,GAAG,GAAP;AACH,OAHD,MAGO;AACH,QAAA,IAAI,GAAG,KAAK,WAAL,CAAiB,GAAjB,EAAsB,MAAtB,CAAP;AACH;;AAED,UAAM,MAAM,GAAG,KAAK,gBAAL,CAAsB,IAAtB,EAA4B,MAA5B,CAAf;AACA,aAAO,IAAI,SAAJ,CAAc,MAAd,EAAsB,MAAtB,EAA8B,WAA9B,CAAP;AACH;AAED;;;;;;;AAjJJ;AAAA;AAAA,qCAuJqB,IAvJrB,EAuJmC,MAvJnC,EAuJ0D;AAClD,cAAQ,MAAR;AACI,aAAK,eAAe,CAAC,eAArB;AACA,aAAK,eAAe,CAAC,eAArB;AACA,aAAK,eAAe,CAAC,eAArB;AACA,aAAK,eAAe,CAAC,eAArB;AACA,aAAK,eAAe,CAAC,iBAArB;AACA,aAAK,eAAe,CAAC,iBAArB;AACA,aAAK,eAAe,CAAC,iBAArB;AACA,aAAK,eAAe,CAAC,iBAArB;AACA,aAAK,eAAe,CAAC,kBAArB;AACI,iBAAO,KAAK,qBAAL,CAA2B,IAA3B,CAAP;;AACJ,aAAK,eAAe,CAAC,eAArB;AACI,iBAAO,KAAK,qBAAL,CAA2B,IAA3B,CAAP;AACJ;AACA;;AACA;AACI,gBAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AAhBR;AAkBH;AAED;;;;;;AA5KJ;AAAA;AAAA,0CAiL0B,IAjL1B,EAiLsC;AAC9B,UAAM,EAAE,GAAG,IAAI,QAAQ,CAAC,EAAb,CAAgB,KAAK,UAAL,CAAgB,KAAhB,CAAsB,MAAtC,CAAX;AACA,UAAM,MAAM,GAAG,EAAE,CAAC,IAAH,CAAQ,IAAR,EAAc,KAAK,GAAnB,EAAwB;AAAE,QAAA,SAAS,EAAE;AAAb,OAAxB,CAAf;AACA,aAAO,MAAM,CAAC,MAAP,CAAc,CACjB,MAAM,CAAC,CAAP,CAAS,WAAT,CAAqB,MAArB,EAA6B,IAA7B,EAAmC,EAAnC,CADiB,EAEjB,MAAM,CAAC,CAAP,CAAS,WAAT,CAAqB,MAArB,EAA6B,IAA7B,EAAmC,EAAnC,CAFiB,CAAd,EAGJ,QAHI,CAGK,KAHL,CAAP;AAIH;AAED;;;;;;AA1LJ;AAAA;AAAA,0CA+L0B,IA/L1B,EA+LsC;AAC9B,UAAM,KAAK,GAAG,IAAI,QAAQ,CAAC,KAAb,CAAmB,KAAK,UAAL,CAAgB,KAAhB,CAAsB,MAAzC,CAAd;AACA,UAAM,MAAM,GAAG,KAAK,CAAC,IAAN,CAAW,IAAX,EAAiB,KAAK,GAAtB,EAA2B,IAA3B,CAAf;AACA,aAAO,MAAM,CAAC,MAAP,CAAc,CACjB,MAAM,CAAC,CAAP,CAAS,WAAT,CAAqB,MAArB,EAA6B,IAA7B,EAAmC,EAAnC,CADiB,EAEjB,MAAM,CAAC,CAAP,CAAS,WAAT,CAAqB,MAArB,EAA6B,IAA7B,EAAmC,EAAnC,CAFiB,CAAd,EAGJ,QAHI,CAGK,KAHL,CAAP;AAIH;AAtML;AAAA;;AACI;;;;;AADJ,2BAMkB,OANlB,EAMqC,UANrC,EAM+D;AACvD,aAAO,IAAI,UAAJ,CAAe,WAAW,CAAC,EAAD,CAA1B,EAAgC,OAAhC,EAAyC,UAAzC,CAAP;AACH;AARL;;AAAA;AAAA,EAAgC,GAAhC","sourcesContent":["import * as elliptic from 'elliptic';\nimport { randomBytes, isBase64 } from \"../common/functionsUtils\";\nimport { ERROR_CODE } from \"../common/error\";\nimport { Key } from \"./key\"\nimport { KeyType, KeyParameters, SignatureScheme } from \"./cryptoParams\";\nimport { PublicKey } from \"./publicKey\";\nimport { Address } from \"../wallet/address\";\nimport { encryptWithGcm, decryptWithGcm, ScryptParams } from \"./scrypt\";\nimport { Signature } from \"./signature\";\nimport { Signable} from \"./signable\";\nimport { DEFAULT_SCRYPT } from \"../common/consts\";\n\nexport class PrivateKey extends Key {\n    /**\n     * Generates random Private key using supplied Key type and parameters.\n     *\n     * If no Key type or parameters is supplied, default SDK key type with default parameters will be used.\n     */\n    static random(keyType?: KeyType, parameters?: KeyParameters): PrivateKey {\n        return new PrivateKey(randomBytes(32), keyType, parameters);\n    }\n\n    /**\n     * Derives Public key out of Private key.\n     */\n    getPublicKey(): PublicKey {\n        switch (this.algorithm) {\n            case KeyType.ECDSA:\n                return this.getEcDSAPublicKey();\n            case KeyType.EDDSA:\n                return this.getEdDSAPublicKey();\n            // case KeyType.SM2:\n            //     return this.getSM2PublicKey();\n            default:\n                throw new Error('Unsupported signature schema.');\n        }\n    }\n\n    /**\n     * Derives Public key out of Private key using EcDSA algorithm.\n     */\n    getEcDSAPublicKey(): PublicKey {\n        const ec = new elliptic.ec(this.parameters.curve.preset);\n        const keyPair = ec.keyFromPrivate(this.key, 'hex');\n        const pk = keyPair.getPublic(true, 'hex');\n\n        return new PublicKey(pk, this.algorithm, this.parameters);\n    }\n\n    /**\n     * Derives Public key out of Private key using EdDSA algorithm.\n     */\n    getEdDSAPublicKey(): PublicKey {\n        const eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n        const keyPair = eddsa.keyFromSecret(this.key, 'hex');\n        const pk = keyPair.getPublic(true, 'hex');\n\n        return new PublicKey(pk, this.algorithm, this.parameters);\n    }\n\n    /**\n     * Decrypts encrypted private key with supplied password.\n     *\n     * @param keyphrase Password to decrypt with\n     * @param address For aad in decryption\n     * @param 16 secure random bytes\n     */\n    decrypt(keyphrase: string, address: Address, salt: string, n?: number): PrivateKey {\n        if (salt.length === 24 && isBase64(salt)) {\n            salt = Buffer.from(salt, 'base64').toString('hex');\n        }\n        let params;\n        if (!n) {\n            params = DEFAULT_SCRYPT;\n        } else {\n            params = {\n                cost: n,\n                blockSize: 8,\n                parallel: 8,\n                size: 64\n            };\n        }\n        const decrypted = decryptWithGcm(this.key, address, salt, keyphrase, params);\n        const decryptedKey = new PrivateKey(decrypted, this.algorithm, this.parameters);\n        const pk = decryptedKey.getPublicKey();\n        const addrTmp = Address.fromPubKey(pk);\n        if (addrTmp.toBase58() !== address.toBase58()) {\n            throw ERROR_CODE.Decrypto_ERROR;\n        }\n        return decryptedKey;\n    }\n\n    /**\n     * Encrypts private key with supplied password.\n     *\n     * @param keyphrase Password to encrypt with\n     * @param address For aad in encryption\n     * @param salt 16 secure random bytes\n     */\n    encrypt(keyphrase: string, address: Address, salt: string, n?: number): PrivateKey {\n        const publicKey = this.getPublicKey();\n        const addr = Address.fromPubKey(publicKey).toBase58();\n        if (addr !== address.toBase58()) {\n            throw ERROR_CODE.INVALID_ADDR;\n        }\n        let params;\n        if (!n) {\n            params = DEFAULT_SCRYPT;\n        } else {\n            params = {\n                cost: n,\n                blockSize: 8,\n                parallel: 8,\n                size: 64\n            };\n        }\n        const encrypted = encryptWithGcm(this.key, address, salt, keyphrase, params);\n        return new PrivateKey(encrypted, this.algorithm, this.parameters);\n    }\n\n    /**\n     * Signs the data with supplied private key using signature schema.\n     *\n     * If the signature schema is not provided, the default schema for this key type is used.\n     *\n     * This method is not suitable, if external keys (Ledger, TPM, ...) support is required.\n     *\n     * @param msg Hex encoded input data or Signable object\n     * @param schema Signing schema to use\n     * @param publicKeyId Id of public key\n     */\n    sign(msg: string | Signable, schema?: SignatureScheme, publicKeyId?: string): Signature {\n        if (schema === undefined) {\n            schema = this.algorithm.defaultSchema;\n        }\n\n        if (!this.isSchemaSupported(schema)) {\n            throw new Error('Signature schema does not match key type.');\n        }\n\n        // retrieves content to sign if not provided directly\n        if (typeof msg !== 'string') {\n            msg = msg.getSignContent();\n        }\n\n        let hash: string;\n        if (schema === SignatureScheme.SM2withSM3) {\n            // library sm.js (SM2withSM3) has implemented hashing as part of signing, therefore it is skipped\n            hash = msg;\n        } else {\n            hash = this.computeHash(msg, schema);\n        }\n\n        const signed = this.computeSignature(hash, schema);\n        return new Signature(schema, signed, publicKeyId);\n    }\n\n    /**\n     * Computes signature of message hash using specified signature schema.\n     *\n     * @param hash Message hash\n     * @param schema Signature schema to use\n     */\n    computeSignature(hash: string, schema: SignatureScheme): string {\n        switch (schema) {\n            case SignatureScheme.ECDSAwithSHA224:\n            case SignatureScheme.ECDSAwithSHA256:\n            case SignatureScheme.ECDSAwithSHA384:\n            case SignatureScheme.ECDSAwithSHA512:\n            case SignatureScheme.ECDSAwithSHA3_224:\n            case SignatureScheme.ECDSAwithSHA3_256:\n            case SignatureScheme.ECDSAwithSHA3_384:\n            case SignatureScheme.ECDSAwithSHA3_512:\n            case SignatureScheme.ECDSAwithRIPEMD160:\n                return this.computeEcDSASignature(hash);\n            case SignatureScheme.EDDSAwithSHA512:\n                return this.computeEdDSASignature(hash);\n            // case SignatureScheme.SM2withSM3:\n            //     return this.computeSM2Signature(hash);\n            default:\n                throw new Error('Unsupported signature schema.');\n        }\n    }\n\n    /**\n     * Computes EcDSA signature of message hash. Curve name is derrived from private key.\n     *\n     * @param hash Message hash\n     */\n    computeEcDSASignature(hash: string): string {\n        const ec = new elliptic.ec(this.parameters.curve.preset);\n        const signed = ec.sign(hash, this.key, { canonical: true });\n        return Buffer.concat([\n            signed.r.toArrayLike(Buffer, 'be', 32),\n            signed.s.toArrayLike(Buffer, 'be', 32)\n        ]).toString('hex');\n    }\n\n    /**\n     * Computes EdDSA signature of message hash. Curve name is derrived from private key.\n     *\n     * @param hash Message hash\n     */\n    computeEdDSASignature(hash: string): string {\n        const eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n        const signed = eddsa.sign(hash, this.key, null);\n        return Buffer.concat([\n            signed.R.toArrayLike(Buffer, 'be', 32),\n            signed.S.toArrayLike(Buffer, 'be', 32)\n        ]).toString('hex');\n    }\n\n}\n"],"sourceRoot":""}]}