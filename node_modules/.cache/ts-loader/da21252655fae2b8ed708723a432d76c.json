{"remainingRequest":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js!/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js??ref--13-2!/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/signature.ts","dependencies":[{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/signature.ts","mtime":1555653862000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import _parseInt from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/core-js/parse-int\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport _classCallCheck from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport * as b64 from 'base64-url';\nimport { StringReader } from \"../common/classesUtils\";\nimport { num2hexstring } from '../common/functionsUtils';\nimport { SignatureScheme } from './cryptoParams';\n/**\n * Signature generated by signing data with Private Key.\n */\n\nexport var Signature =\n/*#__PURE__*/\nfunction () {\n  _createClass(Signature, null, [{\n    key: \"deserializeJWT\",\n    value: function deserializeJWT(encoded, algorithm, publicKeyId) {\n      var decoded = b64.decode(encoded, 'hex');\n      return new Signature(algorithm, decoded, publicKeyId);\n    }\n    /**\n     * Deserializes PgpSignature to Signature.\n     * @param pgpSignature PgpSignature\n     */\n\n  }, {\n    key: \"deserializePgp\",\n    value: function deserializePgp(pgpSignature) {\n      var value = new Buffer(pgpSignature.Value, 'base64').toString('hex');\n      var deserialzedValue = Signature.deserializeHex(value).value;\n      return new Signature(SignatureScheme.fromLabel(pgpSignature.Algorithm), deserialzedValue);\n    }\n    /**\n     * Deserializes hex representation to Signature\n     * @param data hex string\n     */\n\n  }, {\n    key: \"deserializeHex\",\n    value: function deserializeHex(data) {\n      if (data.length < 4) {\n        throw new Error('Invalid params.');\n      }\n\n      var sr = new StringReader(data);\n\n      var scheme = _parseInt(sr.read(1), 16);\n\n      var sigScheme = SignatureScheme.fromHex(scheme);\n      var value = data.substr(2);\n      var sig = new Signature(sigScheme, value);\n      return sig;\n    }\n  }]);\n\n  function Signature(algorithm, value, publicKeyId) {\n    _classCallCheck(this, Signature);\n\n    this.algorithm = algorithm;\n    this.value = value;\n    this.publicKeyId = publicKeyId;\n  }\n  /**\n   * Serializes signature to Hex representation.\n   * For transfer to java backend and verify it.\n   */\n\n\n  _createClass(Signature, [{\n    key: \"serializeHex\",\n    value: function serializeHex() {\n      var result = '';\n      result += num2hexstring(this.algorithm.hex);\n      result += this.value;\n      return result;\n    }\n    /**\n     * Serializes signature to base64url format.\n     */\n\n  }, {\n    key: \"serializeJWT\",\n    value: function serializeJWT() {\n      return b64.encode(this.value, 'hex');\n    }\n  }]);\n\n  return Signature;\n}();",{"version":3,"sources":["/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/signature.ts"],"names":[],"mappings":";;;;;AAAA,OAAO,KAAK,GAAZ,MAAqB,YAArB;AACA,SAAS,YAAT,QAA6B,wBAA7B;AACA,SAAS,aAAT,QAA8B,0BAA9B;AACA,SAAS,eAAT,QAAgC,gBAAhC;AAEA;;;;AAGA,WAAa,SAAb;AAAA;AAAA;AAAA;AAAA;AAAA,mCAC0B,OAD1B,EAC2C,SAD3C,EACuE,WADvE,EAC0F;AAClF,UAAM,OAAO,GAAG,GAAG,CAAC,MAAJ,CAAW,OAAX,EAAoB,KAApB,CAAhB;AAEA,aAAO,IAAI,SAAJ,CACH,SADG,EAEH,OAFG,EAGH,WAHG,CAAP;AAKH;AAED;;;;;AAXJ;AAAA;AAAA,mCAe0B,YAf1B,EAeoD;AAC5C,UAAM,KAAK,GAAG,IAAI,MAAJ,CAAW,YAAY,CAAC,KAAxB,EAA+B,QAA/B,EAAyC,QAAzC,CAAkD,KAAlD,CAAd;AACA,UAAM,gBAAgB,GAAG,SAAS,CAAC,cAAV,CAAyB,KAAzB,EAAgC,KAAzD;AACA,aAAO,IAAI,SAAJ,CACH,eAAe,CAAC,SAAhB,CAA0B,YAAY,CAAC,SAAvC,CADG,EAEH,gBAFG,CAAP;AAIH;AAED;;;;;AAxBJ;AAAA;AAAA,mCA4B0B,IA5B1B,EA4BsC;AAC9B,UAAI,IAAI,CAAC,MAAL,GAAc,CAAlB,EAAqB;AACjB,cAAM,IAAI,KAAJ,CAAU,iBAAV,CAAN;AACH;;AACD,UAAM,EAAE,GAAG,IAAI,YAAJ,CAAiB,IAAjB,CAAX;;AACA,UAAM,MAAM,GAAG,UAAS,EAAE,CAAC,IAAH,CAAQ,CAAR,CAAT,EAAqB,EAArB,CAAf;;AACA,UAAM,SAAS,GAAG,eAAe,CAAC,OAAhB,CAAwB,MAAxB,CAAlB;AACA,UAAM,KAAK,GAAG,IAAI,CAAC,MAAL,CAAY,CAAZ,CAAd;AACA,UAAM,GAAG,GAAG,IAAI,SAAJ,CAAc,SAAd,EAAyB,KAAzB,CAAZ;AACA,aAAO,GAAP;AACH;AAtCL;;AAiDI,qBAAY,SAAZ,EAAwC,KAAxC,EAAuD,WAAvD,EAA2E;AAAA;;AACvE,SAAK,SAAL,GAAiB,SAAjB;AACA,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,WAAL,GAAmB,WAAnB;AACH;AAED;;;;;;AAvDJ;AAAA;AAAA,mCA2DgB;AACR,UAAI,MAAM,GAAG,EAAb;AACA,MAAA,MAAM,IAAI,aAAa,CAAC,KAAK,SAAL,CAAe,GAAhB,CAAvB;AACA,MAAA,MAAM,IAAI,KAAK,KAAf;AACA,aAAO,MAAP;AAEH;AAED;;;;AAnEJ;AAAA;AAAA,mCAsEgB;AACR,aAAO,GAAG,CAAC,MAAJ,CAAW,KAAK,KAAhB,EAAuB,KAAvB,CAAP;AACH;AAxEL;;AAAA;AAAA","sourcesContent":["import * as b64 from 'base64-url';\nimport { StringReader } from \"../common/classesUtils\";\nimport { num2hexstring } from '../common/functionsUtils';\nimport { SignatureScheme } from './cryptoParams';\n\n/**\n * Signature generated by signing data with Private Key.\n */\nexport class Signature {\n    static deserializeJWT(encoded: string, algorithm: SignatureScheme, publicKeyId: string): Signature {\n        const decoded = b64.decode(encoded, 'hex');\n\n        return new Signature(\n            algorithm,\n            decoded,\n            publicKeyId\n        );\n    }\n\n    /**\n     * Deserializes PgpSignature to Signature.\n     * @param pgpSignature PgpSignature\n     */\n    static deserializePgp(pgpSignature: PgpSignature): Signature {\n        const value = new Buffer(pgpSignature.Value, 'base64').toString('hex');\n        const deserialzedValue = Signature.deserializeHex(value).value;\n        return new Signature(\n            SignatureScheme.fromLabel(pgpSignature.Algorithm),\n            deserialzedValue\n        );\n    }\n\n    /**\n     * Deserializes hex representation to Signature\n     * @param data hex string\n     */\n    static deserializeHex(data: string): Signature {\n        if (data.length < 4) {\n            throw new Error('Invalid params.');\n        }\n        const sr = new StringReader(data);\n        const scheme = parseInt(sr.read(1), 16);\n        const sigScheme = SignatureScheme.fromHex(scheme);\n        const value = data.substr(2);\n        const sig = new Signature(sigScheme, value);\n        return sig;\n    }\n\n    algorithm: SignatureScheme;\n    value: string;\n\n    /**\n     * Public key Id used for create this signature.\n     *\n     */\n    publicKeyId?: string;\n\n    constructor(algorithm: SignatureScheme, value: string, publicKeyId?: string) {\n        this.algorithm = algorithm;\n        this.value = value;\n        this.publicKeyId = publicKeyId;\n    }\n\n    /**\n     * Serializes signature to Hex representation.\n     * For transfer to java backend and verify it.\n     */\n    serializeHex(): string {\n        let result = '';\n        result += num2hexstring(this.algorithm.hex);\n        result += this.value;\n        return result;\n\n    }\n\n    /**\n     * Serializes signature to base64url format.\n     */\n    serializeJWT(): string {\n        return b64.encode(this.value, 'hex');\n    }\n}\n\n/**\n * PGP representation of the signature with embedded KeyId\n */\nexport interface PgpSignature {\n    PublicKeyId?: string;\n    Format: 'pgp';\n    Algorithm: string;\n    Value: string;\n}\n"],"sourceRoot":""}]}