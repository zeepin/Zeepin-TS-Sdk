{"remainingRequest":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/thread-loader/dist/cjs.js!/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js!/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js??ref--13-3!/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/programs.ts","dependencies":[{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/packages/sdk/crypto/programs.ts","mtime":1555654574000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/ts-loader/index.js","mtime":1545640398000}],"contextDependencies":[],"result":["import _classCallCheck from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _parseInt from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/core-js/parse-int\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport _getIterator from \"/Users/cindice/Documents/github/Zeepin-TS-Sdk/node_modules/@babel/runtime-corejs2/core-js/get-iterator\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.number.constructor\";\nimport * as elliptic from 'elliptic';\nimport { BigInt } from \"../common/classesUtils\";\nimport { StringReader } from \"../common/classesUtils\";\nimport { PublicKey } from \"./publicKey\";\nimport opcode from \"../common/opCode\";\nimport { num2hexstring } from \"../common/functionsUtils\";\nimport { ERROR_CODE } from \"../common/error\";\nimport { KeyType } from \"./cryptoParams\";\nexport function comparePublicKeys(a, b) {\n  if (a.algorithm !== b.algorithm) {\n    return a.algorithm.hex - b.algorithm.hex;\n  }\n\n  switch (a.algorithm) {\n    case KeyType.ECDSA:\n      var ec = new elliptic.ec(a.parameters.curve.preset);\n      var paKey = ec.keyFromPublic(a.key, 'hex', true);\n      var pbKey = ec.keyFromPublic(b.key, 'hex', true);\n      var pa = paKey.getPublic();\n      var pb = pbKey.getPublic();\n\n      if (pa.getX() !== pb.getX()) {\n        return pa.getX() - pb.getX();\n      } else {\n        return pa.getY() - pb.getY();\n      }\n\n    case KeyType.EDDSA:\n      return Number(a.key) - Number(b.key);\n\n    default:\n      return 0;\n  }\n}\nexport function programFromPubKey(pk) {\n  var result = '';\n  result += pushPubKey(pk);\n  result += pushOpCode(opcode.CHECKSIG);\n  return result;\n}\nexport function programFromMultiPubKey(pubkeys, m) {\n  var n = pubkeys.length;\n\n  if (!(1 <= m && m <= n && n <= 1024)) {\n    throw new Error('Wrong multi-sig param');\n  }\n\n  pubkeys.sort(comparePublicKeys);\n  var result = '';\n  result += pushNum(m);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = _getIterator(pubkeys), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var pk = _step.value;\n      result += pushBytes(pk.serializeHex());\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  result += pushNum(n);\n  result += pushOpCode(opcode.CHECKMULTISIG);\n  return result;\n}\nexport function pushNum(num) {\n  if (num === 0) {\n    return pushOpCode(opcode.PUSH0);\n  } else if (num <= 16) {\n    return num2hexstring(num - 1 + opcode.PUSH1);\n  }\n\n  var bint = new BigInt(num.toString());\n  return pushBytes(bint.toHexstr());\n}\nexport function pushPubKey(pk) {\n  var pkStr = pk.serializeHex();\n  return pushBytes(pkStr);\n}\nexport function pushOpCode(op) {\n  return num2hexstring(op);\n}\nexport function pushBytes(hexstr) {\n  var result = '';\n\n  if (hexstr.length === 0) {\n    throw new Error('pushBytes error, hexstr is empty.');\n  }\n\n  var len = hexstr.length / 2;\n\n  if (len <= opcode.PUSHBYTES75 + 1 - opcode.PUSHBYTES1) {\n    result += num2hexstring(len + opcode.PUSHBYTES1 - 1);\n  } else if (len < 0x100) {\n    result += num2hexstring(opcode.PUSHDATA1);\n    result += num2hexstring(len);\n  } else if (len < 0x10000) {\n    result += num2hexstring(opcode.PUSHDATA2);\n    result += num2hexstring(len, 2, true);\n  } else if (len < 0x100000000) {\n    result += num2hexstring(opcode.PUSHDATA4);\n    result += num2hexstring(len, 4, true);\n  } else {\n    throw ERROR_CODE.INVALID_PARAMS;\n  }\n\n  result += hexstr;\n  return result;\n}\nexport function readOpcode(sr) {\n  return _parseInt(sr.read(1), 16);\n}\nexport function readBytes(sr) {\n  var code = readOpcode(sr);\n  var keylen;\n\n  if (code === opcode.PUSHDATA4) {\n    keylen = sr.readUint32();\n  } else if (code === opcode.PUSHDATA2) {\n    keylen = sr.readUint16();\n  } else if (code === opcode.PUSHDATA1) {\n    keylen = sr.readUint8();\n  } else if (code <= opcode.PUSHBYTES75 && code >= opcode.PUSHBYTES1) {\n    keylen = code - opcode.PUSHBYTES1 + 1;\n  } else {\n    throw new Error('unexpected opcode: ' + code);\n  }\n\n  return sr.read(keylen);\n}\nexport function getParamsFromProgram(hexstr) {\n  var sigs = [];\n  var sr = new StringReader(hexstr);\n\n  while (!sr.isEmpty()) {\n    sigs.push(readBytes(sr));\n  }\n\n  return sigs;\n}\nexport var ProgramInfo = function ProgramInfo() {\n  _classCallCheck(this, ProgramInfo);\n\n  this.M = 0;\n  this.pubKeys = [];\n};\nexport function readPubKey(sr) {\n  var pkStr = sr.readNextBytes();\n  return PublicKey.deserializeHex(new StringReader(pkStr));\n}\nexport function getProgramInfo(hexstr) {\n  var info = new ProgramInfo();\n\n  var end = _parseInt(hexstr.substr(-2, 2), 16);\n\n  if (end === opcode.CHECKSIG) {\n    var sr = new StringReader(hexstr);\n    var pk = readPubKey(sr);\n    info.M = 1;\n    info.pubKeys = [pk];\n    return info;\n  } else if (end === opcode.CHECKMULTISIG) {\n    var _sr = new StringReader(hexstr);\n\n    var m = _parseInt(_sr.read(1), 16) - opcode.PUSH1 + 1;\n    var n = _parseInt(hexstr.substr(-4, 2), 16) - opcode.PUSH1 + 1;\n    info.M = m;\n    info.pubKeys = [];\n\n    for (var i = 0; i < n; i++) {\n      var key = readPubKey(_sr);\n      info.pubKeys.push(key);\n    } // const n = readNum(sr);\n\n\n    return info;\n  } else {\n    throw new Error('Unsupported program.');\n  }\n}\nexport function programFromParams(sigs) {\n  var result = '';\n  sigs.sort();\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = _getIterator(sigs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var s = _step2.value;\n      result += pushBytes(s);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return result;\n}",null]}